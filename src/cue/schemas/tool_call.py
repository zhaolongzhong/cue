from typing import Union, Optional

from pydantic import BaseModel, field_validator


class Function(BaseModel):
    arguments: str
    name: str


class ToolCall(BaseModel):
    id: str
    """The ID of the tool call."""
    function: Union[Function, dict]
    """The function that the model called."""
    type: str

    @field_validator("function", mode="before")
    @classmethod
    def ensure_function_dict(cls, v):
        return v if isinstance(v, dict) else v.model_dump()


class AssistantMessage(BaseModel):
    role: str
    content: Optional[str] = None
    name: Optional[str] = None
    """An optional name for the participant.

    Provides the model information to differentiate between participants of the same
    role.
    """
    tool_calls: Optional[list[ToolCall]] = None
    """The tool calls generated by the model, such as function calls."""

    @field_validator("role", mode="before")
    def check_role(cls, value):
        if value not in ["assistant"]:
            raise ValueError('Role must be "assistant"')
        return value

    @field_validator("tool_calls", mode="before")
    def check_tool_calls(cls, value):
        if value is None:
            return []
        return value


class ToolMessage(BaseModel):
    content: str
    """The content of the tool message."""
    role: str
    tool_call_id: str
    """Tool call that this message is responding to."""

    @field_validator("role", mode="before")
    def check_role(cls, value):
        if value not in ["tool"]:
            raise ValueError('Role must be "tool"')
        return value


def convert_to_assistant_message(chat_message: any) -> AssistantMessage:
    tool_calls = [ToolCall(id=call.id, function=call.function, type=call.type) for call in chat_message.tool_calls]
    return AssistantMessage(content=chat_message.content, role=chat_message.role, tool_calls=tool_calls)
